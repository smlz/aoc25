from collections import Counter
from fractions import Fraction
from itertools import combinations, chain, product
import pathlib
import re

##########
# PART 1 #
##########

def test_light_indicators(lights, toggles):
    for n in range(1, len(toggles) + 1):
        for comb in combinations(toggles, n):
            counts = Counter(chain(*comb))
            if all(on == (counts[i] % 2 == 1) for i, on in enumerate(lights)):
                return n
    raise Exception("No button combination found")

def process_line_part_1(line):
    lights, toggles, joltages = re.match(r"\[([\.#]+)\] ([ \d\(\),]+) \{([\d,]+)\}", line).groups()
    lights = [c == '#' for c in lights]
    toggles = tuple(tuple(int(n) for n in w[1:-1].split(',')) for w in toggles.split())
    return test_light_indicators(lights, toggles)

##########
# PART 2 #
##########

def print_matrix(matrix):
    # Code (mostly) generated by duck.ai
    max_length = max(len(str(item)) for row in matrix for item in row) + 1
    total_columns = len(matrix[0]) if matrix else 0
    header = " " * max_length
    for col in range(total_columns):
        header += f"{col:<{max_length}}"
    print(f"  {header}")
    print('   ' + '-' * (max_length * total_columns))
    for row_index, row in enumerate(matrix):
        row_display = f"{row_index} |"
        for item in row:
            row_display += f"{str(item):>{max_length}}"
        print(f"{row_display}|")
    print('   ' + '-' * (max_length * total_columns))

def gauss(matrix):
    """Gaussion elimination for augmented matrices

    Also returns the list of the free variables
    """
    free_vars = []
    row_idx, col_idx = 0, 0
    m, n = len(matrix), len(matrix[0])
    while row_idx < m and col_idx < n-1:
        # preferably find a one or another value different from zero in current column
        pivot_idx, pivot = 0, 0
        for idx in range(row_idx, m):
            val = matrix[idx][col_idx]
            if abs(val) == 1:
                pivot_idx, pivot = idx, val
                break
            elif val != 0:
                pivot_idx, pivot = idx, val
        # no pivot found
        if pivot == 0:
            free_vars.append(col_idx)
            col_idx += 1
        else:
            # swap rows
            matrix[pivot_idx], matrix[row_idx] = matrix[row_idx], matrix[pivot_idx]
            # reduce the rows below the pivot
            for i in range(row_idx + 1, m):
                # use integers if possible, fractions if needed
                if matrix[i][col_idx] % pivot != 0:
                    f = Fraction(matrix[i][col_idx]) / pivot
                else:
                    f = matrix[i][col_idx] // pivot
                matrix[i][col_idx] = 0
                for j in range(col_idx + 1, n):
                    matrix[i][j] = matrix[i][j] - f * matrix[row_idx][j]
            if debug:
                print(f"after processing pivot at row {row_idx} and col {col_idx}")
                print_matrix(matrix)
            col_idx += 1
            row_idx += 1

    # add remaining free variables
    free_vars.extend(range(col_idx, n - 1))
    return free_vars

def check_free_vars_comb(matrix, free_vars=(), vals=(), current_min=float("inf")):
    """Check if the given combination of free variables has a valid positive integer solution

    Returns the sum of all free variable values or float("inf") if no integer solution was found
    or the computed sum is larger then the provided `current_min`.
    """
    if debug: print("vals", vals, "free_vars", free_vars)
    m = len(matrix)
    n = len(matrix[0])
    vals = dict(zip(free_vars, vals))
    for i in range(0, len(matrix)):
        if debug: print("current row:", len(matrix) - i, "known variables:", vals)
        # start from the bottom
        row = matrix[(-1) - i][:]
        # apply currently known values
        for j, v in vals.items():
            row[j] *= v
        # find pivot position
        for pivot_idx in range(0, n - 1):
            if row[pivot_idx] != 0:
                break
        else:
            # all zero?
            assert row[-1] == 0
            continue
        pivot = row[pivot_idx]
        # solve the equation
        s = row[-1] - sum(row[pivot_idx + 1: -1])
        if s % pivot != 0 or s // pivot < 0:
            # not a valid positive integer number, let's stop
            if debug: print("no valid solution found:", s / pivot)
            return float("inf")
        else:
            vals[pivot_idx] = s // pivot

        if sum(vals.values()) >= current_min:
            # already no improvement, let's stop
            if debug: print("not better", vals, sum(vals.values()), ">=", current_min)
            return float("inf")

    if debug: print("new good set of values found:", vals, "sum:", sum(vals.values()))
    return sum(vals.values())


def process_line_part_2(line):
    lights, toggles, joltages = re.match(r"\[([\.#]+)\] ([ \d\(\),]+) \{([\d,]+)\}", line).groups()
    toggles = tuple(tuple(int(n) for n in w[1:-1].split(',')) for w in toggles.split())
    joltages = tuple(int(n) for n in joltages.split(","))

    # build matrix
    matrix = []
    for i in range(len(joltages)):
        row = []
        for j in range(len(toggles)):
            row.append(1 if i in toggles[j] else 0)
        row.append(joltages[i])
        matrix.append(row)

    if debug: print_matrix(matrix)
    # use gaussian elemination to reduce matrix to row echelon form and to identify free variables
    free_vars = gauss(matrix)

    # now lets brute force through all plausible values for the remaining free variables
    current_min = float("inf")
    for vals in product(*(range(0, min(joltages[j] for j in toggles[i])) for i in free_vars)):
        s = check_free_vars_comb(matrix, free_vars, vals, current_min)
        if s < current_min:
            current_min = s

    return current_min
            

debug = False
if __name__ == '__main__':
    import time
    start = time.perf_counter()

    data_raw = (pathlib.Path(__file__).parent / "day10.txt").read_text().strip().split("\n")
    if debug:
        data_raw = """
[.##.] (3) (1,3) (2) (2,3) (0,2) (0,1) {3,5,4,7}
[...#.] (0,2,3,4) (2,3) (0,4) (0,1,2) (1,2,3,4) {7,5,12,7,2}
[.###.#] (0,1,2,3,4) (0,3,4) (0,1,2,4,5) (1,2) {10,11,11,5,10,5}""".strip().split("\n")

    print("part 1:", sum(map(process_line_part_1, data_raw)))
    
    if not debug:
        import multiprocessing
        # use all cores: execution time around 3 seconds
        with multiprocessing.Pool() as p:
            print("part 2:", sum(p.map(process_line_part_2, data_raw)))
    else:
        # around 7 seconds sequentially
        print("part 2:", sum(map(process_line_part_2, data_raw)))
    print("time:", time.perf_counter() - start)
